{"version":3,"sources":["Pages/mainPage.js","Pages/infoPage.js","Pages/helpPage.js","Page.js","index.js"],"names":["MainPage","props","gridheight","dx","dy","state","playing","algorithm","tile","playError","startPlaced","endPlaced","gridlength","parseInt","window","innerWidth","grid","updateGrid","updateWidth","bind","addEventListener","this","removeEventListener","prevGrid","length","i","push","setState","splice","row","column","j","map","row_index","index","className","onClick","undefined","updateCell","clearPath","dijkstra","aStar","bfs","dfs","coord","path","a","Q","Set","add","toString","dist","prev","Infinity","firstRun","u","prevU","min","size","updateVisited","Promise","r","setTimeout","delete","validCoord","alt","setPath","currNode","shift","current","pop","cameFrom","gScore","fScore","manhattan","node","reconstructPath","tentativeGScore","listNotWithinSet","Math","abs","changeAlgorithm","changeTile","id","playAlgorithm","clearGrid","createGrid","React","Component","InfoPage","HelpPage","useState","selectedTile","setTile","Page","page","newPage","changePage","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.366c1d8e.chunk.js","sourcesContent":["import React from 'react';\r\nimport './mainPage.css';\r\n\r\nclass MainPage extends React.Component{\r\n    \r\n  constructor(props) {\r\n      super(props);\r\n      this.gridheight = 14;\r\n      this.dx = [0,1,0,-1]; // direction matrix \r\n      this.dy = [-1,0,1,0];\r\n      this.state = {playing: false, algorithm: \"Dijkstra\", tile: \"Start\", playError: false, startPlaced: [false,0,0], endPlaced: [false,0,0], gridlength: parseInt(window.innerWidth/35), grid: this.updateGrid([],parseInt(window.innerWidth/35),this.gridheight)};\r\n      this.updateWidth = this.updateWidth.bind(this);\r\n    }\r\n  componentDidMount() {\r\n    window.addEventListener(\"resize\", this.updateWidth); // event listener to check if window is resized\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.removeEventListener(\"resize\", this.updateWidth);\r\n  }\r\n  updateGrid(prevGrid, gridlength, gridheight) { // function to update the grid\r\n    if (prevGrid.length === 0) { // runs if the grid has not been created yet\r\n      for (let i=0; i<gridheight; i++) {\r\n        prevGrid.push([]);\r\n      }\r\n    }\r\n    while (prevGrid[prevGrid.length-1].length !== gridlength) { // runs while the length of the grid and the value of the state \"gridlength\" are not the same \r\n      if (prevGrid[prevGrid.length-1].length < gridlength) { // lengthens the width of the grid\r\n        for (let i=0; i<gridheight; i++) {\r\n          prevGrid[i].push(\"Empty\");\r\n        }   \r\n      } else { // shortens the length of the grid and changes the states, \"startplaced\" and \"endplaced\", if the start or end tiles are removed \r\n        for (let i=0; i<gridheight; i++) {\r\n          if (prevGrid[i][prevGrid[i].length-1] === \"Start\") {\r\n            this.setState({startPlaced: [false,0,0]});\r\n          }\r\n          if (prevGrid[i][prevGrid[i].length-1] === \"End\") {\r\n            this.setState({endPlaced: [false,0,0]});\r\n          }\r\n          prevGrid[i].splice(-1,1)\r\n        }\r\n      }\r\n    }\r\n    return prevGrid;\r\n  }\r\n\r\n  updateWidth() { // updates the width of the grid if the window is resized\r\n    if (this.state.playing === false) {\r\n      this.setState({gridlength: parseInt(window.innerWidth/35)});\r\n      let gridlength = this.state.gridlength;\r\n      let prevGrid = this.state.grid;\r\n      this.setState({grid: this.updateGrid(prevGrid,gridlength,this.gridheight)});\r\n    }\r\n  }\r\n  changeAlgorithm(algorithm) { // updates algorithm state\r\n    this.setState({algorithm: algorithm})\r\n  }\r\n  changeTile(tile) { // updates the tile state\r\n    this.setState({tile: tile})\r\n  }\r\n  updateCell(row, column) { // changes the value of a tile within the grid if the tile is pressed\r\n    let tile = this.state.tile;\r\n    let grid = this.state.grid;\r\n    if (this.state.startPlaced[0] === true) { // these checks make sure that the startplaced and endplaced states are updated if the start or end tiles are placed, moved, or removed\r\n      if(this.state.startPlaced[1] === row && this.state.startPlaced[2] === column) {\r\n        this.setState({startPlaced: [false,0,0]});\r\n      }\r\n    }\r\n    if (this.state.endPlaced[0] === true) {\r\n      if(this.state.endPlaced[1] === row && this.state.endPlaced[2] === column) {\r\n        this.setState({endPlaced: [false,0,0]});\r\n      }\r\n    }\r\n    if (tile === \"Start\") {\r\n      if(this.state.startPlaced[0]===false) {\r\n        this.setState({startPlaced:[true,row,column]});\r\n      } else {\r\n        grid[this.state.startPlaced[1]][this.state.startPlaced[2]] = \"Empty\";\r\n        this.setState({startPlaced:[true,row,column]});\r\n      }\r\n    }\r\n    if (tile === \"End\") {\r\n      if(this.state.endPlaced[0]===false) {\r\n        this.setState({endPlaced:[true,row,column]});\r\n      } else {\r\n        grid[this.state.endPlaced[1]][this.state.endPlaced[2]] = \"Empty\";\r\n        this.setState({endPlaced:[true,row,column]});\r\n      }\r\n    }\r\n    grid[row][column] = tile;\r\n    this.setState({grid: grid});\r\n  }\r\n\r\n  clearGrid() { // sets all tiles in the grid to \"empty\" \r\n    let grid = this.state.grid;\r\n    for (let i = 0; i < this.gridheight; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        grid[i][j] = \"Empty\";\r\n      }\r\n    }\r\n    this.setState({grid: grid, startPlaced: [false,0,0], endPlaced: [false,0,0], playError: false});\r\n  }\r\n\r\n  clearPath() { // clears all path related tiles by setting them to \"empty\"\r\n    let grid = this.state.grid;\r\n    for (let i = 0; i < this.gridheight; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        if (this.state.grid[i][j] === \"Visited\" || this.state.grid[i][j] === \"Path\") {\r\n          grid[i][j] = \"Empty\";\r\n        }\r\n      }\r\n    }\r\n    this.setState({grid: grid});\r\n  }\r\n\r\n  componentDidUpdate() {\r\n  }\r\n\r\n  createGrid() { // creates html for the grid \r\n    return (\r\n      <table>\r\n        <tbody>\r\n          {this.state.grid.map((row,row_index) => <tr key = {row_index}>{row.map((tile,index) => <td className = {tile} onClick={!this.state.playing ? this.updateCell.bind(this,row_index,index) : undefined} key = {(row_index,index)}></td>)}</tr>)}\r\n        </tbody>\r\n      </table>\r\n    );\r\n  }  \r\n\r\n  playAlgorithm() { // plays an algorithm based on the state \"algorithm\"\r\n    if (this.state.startPlaced[0] === true && this.state.endPlaced[0] === true) { // makes sure if the start and end tiles are placed\r\n      this.clearPath();\r\n      this.setState({playError: false, playing: true});\r\n      switch(this.state.algorithm) {\r\n        case \"Dijkstra\":\r\n          this.dijkstra();\r\n          break;\r\n        case \"A*\":\r\n          this.aStar();\r\n          break;\r\n        case \"BFS\":\r\n          this.bfs();\r\n          break;\r\n        case \"DFS\":\r\n          this.dfs();\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    } else {\r\n      this.setState({playError: true});\r\n    }\r\n  }\r\n  \r\n  updateVisited(coord) { // sets tile in grid as \"visited\" if the algorithm visits the tile\r\n    let grid = this.state.grid;\r\n    grid[coord[0]][coord[1]] = \"Visited\";\r\n    grid[this.state.startPlaced[1]][this.state.startPlaced[2]] = \"Start\";\r\n    grid[this.state.endPlaced[1]][this.state.endPlaced[2]] = \"End\";\r\n    this.setState({grid:grid});\r\n  }\r\n\r\n  setPath(path) { // sets tile in grid as \"path\" if the tile is part of the path found by the algorithm \r\n    let grid = this.state.grid;\r\n    grid[path[0]][path[1]] = \"Path\";\r\n    grid[this.state.startPlaced[1]][this.state.startPlaced[2]] = \"Start\";\r\n    grid[this.state.endPlaced[1]][this.state.endPlaced[2]] = \"End\";\r\n    this.setState({grid:grid});\r\n  }\r\n\r\n  validCoord(coord,index) { // checks if the coordinates are valid on the grid\r\n    if (coord[0] + this.dy[index] < 0 || coord[1] + this.dx[index] < 0 || coord[0] + this.dy[index] === this.gridheight || coord[1] + this.dx[index] === this.state.gridlength) {\r\n      return false;\r\n    }\r\n    if (this.state.grid[coord[0] + this.dy[index]][coord[1] + this.dx[index]] === \"Path\" || this.state.grid[coord[0] + this.dy[index]][coord[1] + this.dx[index]] === \"Obstacle\" || this.state.grid[coord[0] + this.dy[index]][coord[1] + this.dx[index]] === \"Visited\" || this.state.grid[coord[0] + this.dy[index]][coord[1] + this.dx[index]] === \"Start\") {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  async dijkstra() {\r\n    \r\n    let Q = new Set(); // creates a queue\r\n    for (let i = 0; i < this.gridheight; i++) {\r\n      for (let j = 0; j < this.state.gridlength; j++) {\r\n        if (this.state.grid[i][j] !== \"Obstacle\") {\r\n          Q.add(i.toString()+\", \"+ j.toString());\r\n        }\r\n      }\r\n    }\r\n\r\n    let dist = []; // initialize the distance and previous node arrays\r\n    let prev = [];\r\n    for (let i = 0; i<this.gridheight; i++) {\r\n      prev.push([]);\r\n      dist.push([]);\r\n      for (let j = 0; j < this.state.gridlength; j++) {\r\n        prev[i].push(undefined);\r\n        dist[i].push(Infinity);\r\n      }\r\n    }\r\n\r\n    dist[this.state.startPlaced[1]][this.state.startPlaced[2]] = 0; // sets distance of start tile to 0\r\n    let firstRun = true;\r\n    let u = [];\r\n    let prevU = [];\r\n    let min = Infinity;\r\n    while (Q.size !== 0) {\r\n      min = Infinity; //  while loop starts by finding tile with minimum distance from the start tile\r\n      if (firstRun) {\r\n        u = [this.state.startPlaced[1], this.state.startPlaced[2]];\r\n        min = 0;\r\n        firstRun = false;\r\n      } else {\r\n        for (let i = 0; i < dist.length; i++) {\r\n          for (let j = 0; j < dist[i].length; j++) {\r\n            if (dist[i][j] < min && this.state.grid[i][j] !== \"Visited\" && this.state.grid[i][j] !== \"Start\") {\r\n              u = [i,j];\r\n              min = dist[i][j];\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (u[0] === prevU[0] && u[1] === prevU[1]) { // function ends if no new tile is found (algorithm could not find path)\r\n        break;\r\n      }\r\n\r\n      this.updateVisited(u); // sets u as visited\r\n      await new Promise(r => setTimeout(r, 25)); // delay function\r\n\r\n      Q.delete(u[0].toString()+\", \"+u[1].toString()); // removes u from the queue\r\n      if (u[0] === this.state.endPlaced[1] && u[1] === this.state.endPlaced[2]) {\r\n        break;\r\n      }\r\n      \r\n      for (let i = 0; i < 4; i++) { // checks each direction (up, down, right, left) for a valid tile/neighbour\r\n        if (this.validCoord(u,i)) {\r\n          let alt = dist[u[0]][u[1]] + 1; // the +1 should be substituted for the weight of the node (since there are no weights in this visualization, each node is weighted as 1)\r\n          if (alt < dist[u[0]+this.dy[i]][u[1]+this.dx[i]]) { // updates the distance and previous node of u's nieghbour if a faster route is found\r\n            dist[u[0]+this.dy[i]][u[1]+this.dx[i]] = alt;\r\n            prev[u[0]+this.dy[i]][u[1]+this.dx[i]] = u;\r\n          }\r\n        }\r\n      }\r\n      prevU = [u[0],u[1]];\r\n    }\r\n    let path = [this.state.endPlaced[1],this.state.endPlaced[2]]; // code to display path\r\n    if (prev[path[0]][path[1]] !== undefined) {\r\n      while (path !== undefined) {\r\n        this.setPath(path);\r\n        await new Promise(r => setTimeout(r, 5));\r\n        path = prev[path[0]][path[1]];\r\n      }\r\n    }\r\n    this.setState({playing: false});\r\n    await new Promise(r => setTimeout(r, 5));\r\n    this.updateWidth();\r\n  }\r\n\r\n  async bfs() { \r\n    let Q = []; // initialize arrays\r\n    let prev = [];\r\n    \r\n    for (let i = 0; i<this.gridheight; i++) {\r\n      prev.push([]);\r\n      for (let j = 0; j < this.state.gridlength; j++) {\r\n        prev[i].push(undefined);\r\n      }\r\n    }\r\n\r\n    Q.push([this.state.startPlaced[1],this.state.startPlaced[2]]); // adds start tile to queue\r\n    while (Q.length !== 0) { // runs while the queue is not empty\r\n      let currNode = Q.shift(); // sets currnode to first element in the queue\r\n      if (currNode[0] === this.state.endPlaced[1] && currNode[1] === this.state.endPlaced[2]) {\r\n        break;\r\n      }\r\n      for (let i = 0; i < 4; i++) { // checks the neighbours of currnode and adds them to the queue\r\n        if (this.validCoord(currNode,i)) {\r\n          Q.push([currNode[0]+this.dy[i],currNode[1]+this.dx[i]]);\r\n          this.updateVisited([currNode[0]+this.dy[i],currNode[1]+this.dx[i]]);\r\n          prev[currNode[0]+this.dy[i]][currNode[1]+this.dx[i]] = currNode;\r\n          await new Promise(r => setTimeout(r, 25));\r\n        }\r\n      }\r\n    }\r\n    let path = [this.state.endPlaced[1],this.state.endPlaced[2]]; // code to display path\r\n    if (prev[path[0]][path[1]] !== undefined) {\r\n      while (path !== undefined) {\r\n        this.setPath(path);\r\n        await new Promise(r => setTimeout(r, 5));\r\n        path = prev[path[0]][path[1]];\r\n      }\r\n    }\r\n    this.setState({playing: false});\r\n    await new Promise(r => setTimeout(r, 5));\r\n    this.updateWidth();\r\n  }\r\n\r\n  async dfs() {\r\n    let Q = []; // initialize arrays\r\n    let prev = [];\r\n    for (let i = 0; i<this.gridheight; i++) {\r\n      prev.push([]);\r\n      for (let j = 0; j < this.state.gridlength; j++) {\r\n        prev[i].push(undefined);\r\n      }\r\n    }\r\n\r\n    Q.push([this.state.startPlaced[1],this.state.startPlaced[2]]); // adds start tile to queue\r\n\r\n    while (Q.length !== 0) { // runs while the queue is not empty\r\n      let current = Q.pop(); // sets current to first element in the queue\r\n      if (current === undefined) {\r\n        break;\r\n      } \r\n      this.updateVisited(current);\r\n      await new Promise(r => setTimeout(r, 25));\r\n      if (current[0] === this.state.endPlaced[1] && current[1] === this.state.endPlaced[2]) {\r\n        break;\r\n      }\r\n\r\n      if (this.validCoord(current,0)) { // each if statement is to determine the next direction taken by the algorithm in the order: up, right, down, left.\r\n        prev[current[0]+this.dy[0]][current[1]+this.dx[0]] = current;\r\n        Q.push([current[0]+this.dy[0],current[1]+this.dx[0]]);\r\n\r\n      } else if (this.validCoord(current,1)) {\r\n        prev[current[0]+this.dy[1]][current[1]+this.dx[1]] = current;\r\n        Q.push([current[0]+this.dy[1],current[1]+this.dx[1]]);\r\n\r\n      } else if (this.validCoord(current,2)) {\r\n        prev[current[0]+this.dy[2]][current[1]+this.dx[2]] = current;\r\n        Q.push([current[0]+this.dy[2],current[1]+this.dx[2]]);\r\n\r\n      } else if (this.validCoord(current,3)) {\r\n        prev[current[0]+this.dy[3]][current[1]+this.dx[3]] = current;\r\n        Q.push([current[0]+this.dy[3],current[1]+this.dx[3]]);\r\n      } else { // if no move is possible, the previous node of current is pushed onto the queue \r\n        Q.push(prev[current[0]][current[1]]);\r\n      }\r\n    }\r\n\r\n    let path = [this.state.endPlaced[1],this.state.endPlaced[2]]; // code to display path\r\n    if (prev[path[0]][path[1]] !== undefined) {\r\n      while (path !== undefined) {\r\n        this.setPath(path);\r\n        await new Promise(r => setTimeout(r, 5));\r\n        path = prev[path[0]][path[1]];\r\n      }\r\n    }\r\n\r\n    this.setState({playing: false});\r\n    await new Promise(r => setTimeout(r, 5));\r\n    this.updateWidth();\r\n  }\r\n\r\n  async aStar() {\r\n    let Q = new Set();\r\n    Q.add([this.state.startPlaced[1],this.state.startPlaced[2]]);\r\n\r\n    let cameFrom = [];\r\n    let gScore = []; // distance from start to tile\r\n    let fScore = []; // estimated distance from tile to end\r\n    for (let i = 0; i<this.gridheight; i++) {\r\n      cameFrom.push([]);\r\n      gScore.push([]);\r\n      fScore.push([]);\r\n      for (let j = 0; j < this.state.gridlength; j++) {\r\n        cameFrom[i].push(undefined);\r\n        gScore[i].push(Infinity);\r\n        fScore[i].push(Infinity);\r\n      }\r\n    }\r\n    gScore[this.state.startPlaced[1]][this.state.startPlaced[2]] = 0;\r\n    fScore[this.state.startPlaced[1]][this.state.startPlaced[2]] = this.manhattan([this.state.startPlaced[1],this.state.startPlaced[2]]);\r\n\r\n    while (Q.size !== 0) {\r\n      let current = undefined;\r\n      let min = Infinity;\r\n      for (let node of Q) { // finds node with minimum fscore\r\n        if (fScore[node[0]][node[1]] < min) {\r\n          min = fScore[node[0]][node[1]];\r\n          current = node;\r\n        }\r\n      }\r\n\r\n      if (current[0] === this.state.endPlaced[1] && current[1] === this.state.endPlaced[2]) {\r\n        await this.reconstructPath(cameFrom);\r\n        this.setState({playing: false});\r\n        await new Promise(r => setTimeout(r, 5));\r\n        this.updateWidth();\r\n        return true;\r\n      }\r\n\r\n      Q.delete(current);\r\n\r\n      await new Promise(r => setTimeout(r, 25));\r\n      this.updateVisited(current);\r\n      for (let i = 0; i<4; i++) { // checks neighbours of current and updates the information related to them \r\n        if (this.validCoord(current,i)) {\r\n          let tentativeGScore = gScore[current[0]][current[1]] + 1; // the 1 should be replaced with the weight of the edge for weighted graphs\r\n          if (tentativeGScore < gScore[current[0]+this.dy[i]][current[1]+this.dx[i]]) {\r\n            cameFrom[current[0]+this.dy[i]][current[1]+this.dx[i]] = current;\r\n            gScore[current[0]+this.dy[i]][current[1]+this.dx[i]] = tentativeGScore;\r\n            fScore[current[0]+this.dy[i]][current[1]+this.dx[i]] = gScore[current[0]+this.dy[i]][current[1]+this.dx[i]] + this.manhattan([current[0]+this.dy[i],current[1]+this.dx[i]]);\r\n            if (this.listNotWithinSet(Q,[current[0]+this.dy[i],current[1]+this.dx[i]])) {\r\n              Q.add([current[0]+this.dy[i],current[1]+this.dx[i]]);\r\n            }\r\n          }  \r\n        }\r\n      }\r\n\r\n    }\r\n    this.setState({playing: false});\r\n    await new Promise(r => setTimeout(r, 5));\r\n    this.updateWidth();\r\n    return false;\r\n  }\r\n\r\n  listNotWithinSet(Q, coord) { // checks to see if coord is not within the queue\r\n    for (let node of Q) {\r\n      if (node[0] === coord[0] && node[1] === coord[1]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n\r\n  async reconstructPath(cameFrom) { // code to display path\r\n    let current = [this.state.endPlaced[1], this.state.endPlaced[2]];\r\n    while (current !== undefined) {\r\n      this.setPath(current);\r\n      await new Promise(r => setTimeout(r, 5));\r\n      current = cameFrom[current[0]][current[1]];\r\n    }\r\n  }\r\n\r\n  manhattan(coord) { // used to estimate distance from a tile to the end tile\r\n    return Math.abs(coord[0]-this.state.endPlaced[1]) + Math.abs(coord[1]-this.state.endPlaced[2]);\r\n  }\r\n\r\n  render() {\r\n      return (\r\n        <div className=\"visualizer\">\r\n          <div className=\"visualizer-nav\">\r\n            <ul className=\"algorithms\">\r\n              <li><span className = {this.state.algorithm === \"Dijkstra\" ? \"selected\" : \"unselected\"} onClick={this.changeAlgorithm.bind(this, \"Dijkstra\")}> Dijkstra </span></li>\r\n              <li><span className = {this.state.algorithm === \"A*\" ? \"selected\" : \"unselected\"} onClick={this.changeAlgorithm.bind(this, \"A*\")}> A* Search </span></li>\r\n              <li><span className = {this.state.algorithm === \"BFS\" ? \"selected\" : \"unselected\"} onClick={this.changeAlgorithm.bind(this, \"BFS\")}> BFS Search </span></li>\r\n              <li><span className = {this.state.algorithm === \"DFS\" ? \"selected\" : \"unselected\"} onClick={this.changeAlgorithm.bind(this, \"DFS\")}> DFS Search </span></li>\r\n            </ul>\r\n          </div>\r\n          <div className=\"visualizer-grid\">\r\n            <div className=\"grid-options\">\r\n              <ul className=\"tiles\">\r\n                <li><span className = {this.state.tile === \"Start\" ? \"selected\" : \"unselected\"} onClick={this.changeTile.bind(this, \"Start\")}> Start </span></li>\r\n                <li><span className = {this.state.tile === \"End\" ? \"selected\" : \"unselected\"}  onClick={this.changeTile.bind(this, \"End\")}> End </span></li>\r\n                <li><span className = {this.state.tile === \"Obstacle\" ? \"selected\" : \"unselected\"} onClick={this.changeTile.bind(this, \"Obstacle\")}> Wall </span></li>\r\n                <li><span className = {this.state.tile === \"Empty\" ? \"selected\" : \"unselected\"} onClick={this.changeTile.bind(this, \"Empty\")}> Blank </span></li>\r\n              </ul>\r\n              <ul className=\"grid-controls\" id = {!this.state.playing ? \"controls-enabled\" : \"controls-disabled\"}>\r\n                <li><span onClick={!this.state.playing ? this.playAlgorithm.bind(this) : undefined}> Play </span></li>\r\n                <li><span onClick={!this.state.playing ? this.clearPath.bind(this) : undefined}> Clear path </span></li>\r\n                <li><span onClick={!this.state.playing ? this.clearGrid.bind(this) : undefined}> Clear grid </span></li>\r\n              </ul>\r\n              {this.state.playError === true && <div className=\"playError\"> Place the start and end tiles before playing </div>}\r\n            </div>\r\n            <div className=\"grid\">\r\n              {this.createGrid()}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      );\r\n  }\r\n}\r\n\r\nexport default MainPage","import React from 'react';\r\nimport '../Page.css';\r\n\r\n\r\nfunction InfoPage() {\r\n    return (\r\n      <div className=\"info-page\">\r\n        <h1> What is a Pathfinding Algorithm </h1>\r\n          <p> A pathfinding algorithm is an algorithm that explores a graph by starting at one node and then exploring it's neighbours </p>\r\n          <p> The algorithms in this visualization try and find a path on the graph that is the shortest/most efficient path from one point to the next </p>\r\n        <h2> Weighted vs Unweighted </h2>\r\n          <p> Unlike unweighted algorithms, weighted algorithms can calculate the shortest path in a graph where the cost of exploring each node can be different </p>\r\n          <p> Both Dijkstra's algorithm and A* algorithm are wieghted while BFS search and DFS search are both unweighted algorithms </p>\r\n          <p> This visualization doesnt have weights so each node is treated as having a cost of 1. </p>\r\n        <h2> How They Work </h2>\r\n          <h3> Dijstra </h3>\r\n          <p> This algorithm works by first storing the distance each node is from the source node. If the distance is unknown, it is set to Infinity. The algorithm chooses which node to explore based on which node is the closest to the source node and hasn't been explored. As shorter paths are found, the distance values are updated </p>\r\n          <h3> A* </h3>\r\n          <p> This algorithm works by determining which direction to extend it's path. It does this by calculating the distance a node is from the source + the estimated distance the node is from the goal. This algorithm is more efficient than dijkstra's algorithm and has to explore less nodes </p>\r\n          <h3> BFS </h3>\r\n          <p> This algorithm works by exploring nodes connected to the source node in a breadth-first manner. Due to the nature of the algorithm, when the algorithm reaches the goal node, the path taken is the shortest </p>\r\n          <h3> DFS </h3>\r\n          <p> This algorithm works by first choosing a direction to explore. The direction chosen is determined by an order of directions. If no direction can be explored, the algorithm backtracks. The path this algorithm finds may not be the shortest </p>\r\n      </div>\r\n    );\r\n  }\r\n\r\nexport default InfoPage","import React, { useState } from 'react';\r\nimport '../Page.css';\r\n\r\n\r\n\r\nfunction HelpPage() {\r\n  const [selectedTile, changeTile] = useState(0);\r\n  const [tile, setTile] = useState(0);\r\n    return (\r\n      <div className=\"help-page\">\r\n        <h1> How to Visualize </h1>\r\n        <h2> 1 </h2>\r\n        <p> Select an algorithm </p>\r\n        <div className=\"visualizer-nav\">\r\n          <ul className=\"algorithms\">\r\n            <li><span> Dijkstra </span></li>\r\n            <li><span> A* Search </span></li>\r\n            <li><span> BFS Search </span></li>\r\n            <li><span> DFS Search </span></li>\r\n          </ul>\r\n        </div>\r\n        <h2> 2 </h2>\r\n        <p> Select tiles using the buttons on the top left of the grid and place the tiles by pressing a grid cell </p>\r\n        <div className=\"grid-options\">\r\n          <ul className=\"tiles\">\r\n            <li><span onClick={changeTile.bind(this, \"Start\")}> Start </span></li>\r\n            <li><span onClick={changeTile.bind(this, \"End\")}> End </span></li>\r\n            <li><span onClick={changeTile.bind(this, \"Obstacle\")}> Wall </span></li>\r\n            <li><span onClick={changeTile.bind(this, \"Empty\")}> Blank </span></li>\r\n          </ul>\r\n          <ul className=\"grid-controls\">\r\n            <li><span onClick={setTile.bind(this, \"Visited\")}> Play </span></li>\r\n            <li><span onClick = {tile === \"Visited\" ? setTile.bind(this, \"Empty\") : undefined}> Clear path </span></li>\r\n            <li><span onClick={setTile.bind(this, \"Empty\")}> Clear grid </span></li>\r\n          </ul>\r\n        </div>\r\n        <span className={tile} id=\"example-tile\" onClick={setTile.bind(this, selectedTile)}> </span>\r\n        <p> Use the \"clear grid\" button to remove all tiles and use the \"clear path\" button to remove the path tiles generated by the algorithms </p>\r\n        <p> Use the play button to watch the algorithm in action </p>\r\n      </div>\r\n    );\r\n}\r\n\r\n\r\nexport default HelpPage","import React from 'react';\r\nimport './Page.css';\r\nimport MainPage from './Pages/mainPage'\r\nimport InfoPage from './Pages/infoPage'\r\nimport HelpPage from './Pages/helpPage'\r\n\r\nclass Page extends React.Component{\r\n    \r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {page: \"Main\"};\r\n      }\r\n    \r\n    changePage(newPage) {\r\n        this.setState({page: newPage})\r\n    }\r\n\r\n    render() {\r\n        return (\r\n          <div className=\"page\">\r\n            <div className=\"navbar\">\r\n              <div className=\"content\" id = \"title\" onClick={this.changePage.bind(this, \"Main\")}>\r\n                <h1>Pathfinder Visualizer</h1>\r\n              </div>\r\n              <div className=\"content\" id = \"pages\">\r\n                <ul>\r\n                  <li><span className = {this.state.page === \"Main\" ? \"selected\" : \"unselected\"} onClick={this.changePage.bind(this, \"Main\")}> Visualize </span></li>\r\n                  <li><span className = {this.state.page === \"Info\" ? \"selected\" : \"unselected\"} onClick={this.changePage.bind(this, \"Info\")}> Info </span></li>\r\n                  <li><span className = {this.state.page === \"Help\" ? \"selected\" : \"unselected\"} onClick={this.changePage.bind(this, \"Help\")}> Help </span></li>\r\n                </ul>\r\n              </div>\r\n            </div>\r\n            { this.state.page === \"Main\" && <MainPage/>}\r\n            { this.state.page === \"Info\" && <InfoPage/>}\r\n            { this.state.page === \"Help\" && <HelpPage/>}\r\n          </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport default Page","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './Page.css';\nimport Page from \"./Page\"\n\nReactDOM.render( <Page />, document.getElementById('root'));\n\n"],"sourceRoot":""}